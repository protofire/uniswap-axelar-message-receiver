{
    "language": "Solidity",
    "sources": {
      "@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\nimport { IAxelarExecutable } from '../interfaces/IAxelarExecutable.sol';\n\n/**\n * @title AxelarExecutable\n * @dev Abstract contract to be inherited by contracts that need to execute cross-chain commands via Axelar's Gateway.\n * It implements the IAxelarExecutable interface.\n */\nabstract contract AxelarExecutable is IAxelarExecutable {\n    /// @dev Reference to the Axelar Gateway contract.\n    address internal immutable gatewayAddress;\n\n    /**\n     * @dev Contract constructor that sets the Axelar Gateway address.\n     * Reverts if the provided address is the zero address.\n     * @param gateway_ The address of the Axelar Gateway contract.\n     */\n    constructor(address gateway_) {\n        if (gateway_ == address(0)) revert InvalidAddress();\n\n        gatewayAddress = gateway_;\n    }\n\n    /**\n     * @notice Executes the cross-chain command after validating it with the Axelar Gateway.\n     * @dev This function ensures the call is approved by Axelar Gateway before execution.\n     * It uses a hash of the payload for validation and internally calls _execute for the actual command execution.\n     * Reverts if the validation fails.\n     * @param commandId The unique identifier of the cross-chain message being executed.\n     * @param sourceChain The name of the source chain from which the message originated.\n     * @param sourceAddress The address on the source chain that sent the message.\n     * @param payload The payload of the message payload.\n     */\n    function execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external virtual {\n        bytes32 payloadHash = keccak256(payload);\n\n        if (!gateway().validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))\n            revert NotApprovedByGateway();\n\n        _execute(commandId, sourceChain, sourceAddress, payload);\n    }\n\n    /**\n     * @dev Internal virtual function to be overridden by child contracts to execute the command.\n     * It allows child contracts to define their custom command execution logic.\n     * @param commandId The identifier of the command to execute.\n     * @param sourceChain The name of the source chain from which the command originated.\n     * @param sourceAddress The address on the source chain that sent the command.\n     * @param payload The payload of the command to be executed.\n     */\n    function _execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal virtual;\n\n    /**\n     * @notice Returns the address of the AxelarGateway contract.\n     * @return The Axelar Gateway instance.\n     */\n    function gateway() public view returns (IAxelarGateway) {\n        return IAxelarGateway(gatewayAddress);\n    }\n}\n"
      },
      "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarExecutable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from './IAxelarGateway.sol';\n\n/**\n * @title IAxelarExecutable\n * @dev Interface for a contract that is executable by Axelar Gateway's cross-chain message passing.\n * It defines a standard interface to execute commands sent from another chain.\n */\ninterface IAxelarExecutable {\n    /**\n     * @dev Thrown when a function is called with an invalid address.\n     */\n    error InvalidAddress();\n\n    /**\n     * @dev Thrown when the call is not approved by the Axelar Gateway.\n     */\n    error NotApprovedByGateway();\n\n    /**\n     * @notice Returns the address of the AxelarGateway contract.\n     * @return The Axelar Gateway contract associated with this executable contract.\n     */\n    function gateway() external view returns (IAxelarGateway);\n\n    /**\n     * @notice Executes the specified command sent from another chain.\n     * @dev This function is called by the Axelar Gateway to carry out cross-chain commands.\n     * Reverts if the call is not approved by the gateway or other checks fail.\n     * @param commandId The identifier of the command to execute.\n     * @param sourceChain The name of the source chain from where the command originated.\n     * @param sourceAddress The address on the source chain that sent the command.\n     * @param payload The payload of the command to be executed. This typically includes the function selector and encoded arguments.\n     */\n    function execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external;\n}\n"
      },
      "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { GasInfo } from '../types/GasEstimationTypes.sol';\nimport { IInterchainGasEstimation } from './IInterchainGasEstimation.sol';\nimport { IUpgradable } from './IUpgradable.sol';\n\n/**\n * @title IAxelarGasService Interface\n * @notice This is an interface for the AxelarGasService contract which manages gas payments\n * and refunds for cross-chain communication on the Axelar network.\n * @dev This interface inherits IUpgradable\n */\ninterface IAxelarGasService is IInterchainGasEstimation, IUpgradable {\n    error InvalidAddress();\n    error NotCollector();\n    error InvalidAmounts();\n    error InvalidGasUpdates();\n    error InvalidParams();\n    error InsufficientGasPayment(uint256 required, uint256 provided);\n\n    event GasPaidForContractCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasPaidForContractCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForContractCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForContractCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasPaidForExpressCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasPaidForExpressCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForExpressCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForExpressCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasAdded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);\n\n    event ExpressGasAdded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeExpressGasAdded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event Refunded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        address payable receiver,\n        address token,\n        uint256 amount\n    );\n\n    /**\n     * @notice Pay for gas for any type of contract execution on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @dev If estimateOnChain is true, the function will estimate the gas cost and revert if the payment is insufficient.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param executionGasLimit The gas limit for the contract call\n     * @param estimateOnChain Flag to enable on-chain gas estimation\n     * @param refundAddress The address where refunds, if any, should be sent\n     * @param params Additional parameters for gas payment. This can be left empty for normal contract call payments.\n     */\n    function payGas(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        uint256 executionGasLimit,\n        bool estimateOnChain,\n        address refundAddress,\n        bytes calldata params\n    ) external payable;\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for a contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for a contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using native currency for a contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Pay for gas using native currency for a contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for an express contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForExpressCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for an express contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForExpressCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using native currency for an express contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForExpressCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Pay for gas using native currency for an express contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForExpressCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Add additional gas payment using ERC20 tokens after initiating a cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param gasToken The ERC20 token address used to add gas\n     * @param gasFeeAmount The amount of tokens to add as gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Add additional gas payment using native currency after initiating a cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addNativeGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Add additional gas payment using ERC20 tokens after initiating an express cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param gasToken The ERC20 token address used to add gas\n     * @param gasFeeAmount The amount of tokens to add as gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addExpressGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Add additional gas payment using native currency after initiating an express cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addNativeExpressGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Updates the gas price for a specific chain.\n     * @dev This function is called by the gas oracle to update the gas prices for a specific chains.\n     * @param chains Array of chain names\n     * @param gasUpdates Array of gas updates\n     */\n    function updateGasInfo(string[] calldata chains, GasInfo[] calldata gasUpdates) external;\n\n    /**\n     * @notice Allows the gasCollector to collect accumulated fees from the contract.\n     * @dev Use address(0) as the token address for native currency.\n     * @param receiver The address to receive the collected fees\n     * @param tokens Array of token addresses to be collected\n     * @param amounts Array of amounts to be collected for each respective token address\n     */\n    function collectFees(\n        address payable receiver,\n        address[] calldata tokens,\n        uint256[] calldata amounts\n    ) external;\n\n    /**\n     * @notice Refunds gas payment to the receiver in relation to a specific cross-chain transaction.\n     * @dev Only callable by the gasCollector.\n     * @dev Use address(0) as the token address to refund native currency.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param receiver The address to receive the refund\n     * @param token The token address to be refunded\n     * @param amount The amount to refund\n     */\n    function refund(\n        bytes32 txHash,\n        uint256 logIndex,\n        address payable receiver,\n        address token,\n        uint256 amount\n    ) external;\n\n    /**\n     * @notice Returns the address of the designated gas collector.\n     * @return address of the gas collector\n     */\n    function gasCollector() external returns (address);\n}\n"
      },
      "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IAxelarGateway\n * @dev Interface for the Axelar Gateway that supports general message passing and contract call execution.\n */\ninterface IAxelarGateway {\n    /**\n     * @notice Emitted when a contract call is made through the gateway.\n     * @dev Logs the attempt to call a contract on another chain.\n     * @param sender The address of the sender who initiated the contract call.\n     * @param destinationChain The name of the destination chain.\n     * @param destinationContractAddress The address of the contract on the destination chain.\n     * @param payloadHash The keccak256 hash of the sent payload data.\n     * @param payload The payload data used for the contract call.\n     */\n    event ContractCall(\n        address indexed sender,\n        string destinationChain,\n        string destinationContractAddress,\n        bytes32 indexed payloadHash,\n        bytes payload\n    );\n\n    /**\n     * @notice Sends a contract call to another chain.\n     * @dev Initiates a cross-chain contract call through the gateway to the specified destination chain and contract.\n     * @param destinationChain The name of the destination chain.\n     * @param contractAddress The address of the contract on the destination chain.\n     * @param payload The payload data to be used in the contract call.\n     */\n    function callContract(\n        string calldata destinationChain,\n        string calldata contractAddress,\n        bytes calldata payload\n    ) external;\n\n    /**\n     * @notice Checks if a contract call is approved.\n     * @dev Determines whether a given contract call, identified by the commandId and payloadHash, is approved.\n     * @param commandId The identifier of the command to check.\n     * @param sourceChain The name of the source chain.\n     * @param sourceAddress The address of the sender on the source chain.\n     * @param contractAddress The address of the contract where the call will be executed.\n     * @param payloadHash The keccak256 hash of the payload data.\n     * @return True if the contract call is approved, false otherwise.\n     */\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view returns (bool);\n\n    /**\n     * @notice Validates and approves a contract call.\n     * @dev Validates the given contract call information and marks it as approved if valid.\n     * @param commandId The identifier of the command to validate.\n     * @param sourceChain The name of the source chain.\n     * @param sourceAddress The address of the sender on the source chain.\n     * @param payloadHash The keccak256 hash of the payload data.\n     * @return True if the contract call is validated and approved, false otherwise.\n     */\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external returns (bool);\n\n    /**\n     * @notice Checks if a command has been executed.\n     * @dev Determines whether a command, identified by the commandId, has been executed.\n     * @param commandId The identifier of the command to check.\n     * @return True if the command has been executed, false otherwise.\n     */\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\n}\n"
      },
      "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IContractIdentifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// General interface for upgradable contracts\ninterface IContractIdentifier {\n    /**\n     * @notice Returns the contract ID. It can be used as a check during upgrades.\n     * @dev Meant to be overridden in derived contracts.\n     * @return bytes32 The contract ID\n     */\n    function contractId() external pure returns (bytes32);\n}\n"
      },
      "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IGovernable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IGovernable Interface\n * @notice This is an interface used by the AxelarGateway contract to manage governance and mint limiter roles.\n */\ninterface IGovernable {\n    error NotGovernance();\n    error NotMintLimiter();\n    error InvalidGovernance();\n    error InvalidMintLimiter();\n\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\n    event MintLimiterTransferred(address indexed previousGovernance, address indexed newGovernance);\n\n    /**\n     * @notice Returns the governance address.\n     * @return address of the governance\n     */\n    function governance() external view returns (address);\n\n    /**\n     * @notice Returns the mint limiter address.\n     * @return address of the mint limiter\n     */\n    function mintLimiter() external view returns (address);\n\n    /**\n     * @notice Transfer the governance role to another address.\n     * @param newGovernance The new governance address\n     */\n    function transferGovernance(address newGovernance) external;\n\n    /**\n     * @notice Transfer the mint limiter role to another address.\n     * @param newGovernance The new mint limiter address\n     */\n    function transferMintLimiter(address newGovernance) external;\n}\n"
      },
      "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IImplementation.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IContractIdentifier } from './IContractIdentifier.sol';\n\ninterface IImplementation is IContractIdentifier {\n    error NotProxy();\n\n    function setup(bytes calldata data) external;\n}\n"
      },
      "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IInterchainGasEstimation.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { GasEstimationType, GasInfo } from '../types/GasEstimationTypes.sol';\n\n/**\n * @title IInterchainGasEstimation Interface\n * @notice This is an interface for the InterchainGasEstimation contract\n * which allows for estimating gas fees for cross-chain communication on the Axelar network.\n */\ninterface IInterchainGasEstimation {\n    error UnsupportedEstimationType(GasEstimationType gasEstimationType);\n\n    /**\n     * @notice Event emitted when the gas price for a specific chain is updated.\n     * @param chain The name of the chain\n     * @param info The gas info for the chain\n     */\n    event GasInfoUpdated(string chain, GasInfo info);\n\n    /**\n     * @notice Returns the gas price for a specific chain.\n     * @param chain The name of the chain\n     * @return gasInfo The gas info for the chain\n     */\n    function getGasInfo(string calldata chain) external view returns (GasInfo memory);\n\n    /**\n     * @notice Estimates the gas fee for a cross-chain contract call.\n     * @param destinationChain Axelar registered name of the destination chain\n     * @param destinationAddress Destination contract address being called\n     * @param executionGasLimit The gas limit to be used for the destination contract execution,\n     *        e.g. pass in 200k if your app consumes needs upto 200k for this contract call\n     * @param params Additional parameters for the gas estimation\n     * @return gasEstimate The cross-chain gas estimate, in terms of source chain's native gas token that should be forwarded to the gas service.\n     */\n    function estimateGasFee(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        uint256 executionGasLimit,\n        bytes calldata params\n    ) external view returns (uint256 gasEstimate);\n}\n"
      },
      "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IOwnable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IOwnable Interface\n * @notice IOwnable is an interface that abstracts the implementation of a\n * contract with ownership control features. It's commonly used in upgradable\n * contracts and includes the functionality to get current owner, transfer\n * ownership, and propose and accept ownership.\n */\ninterface IOwnable {\n    error NotOwner();\n    error InvalidOwner();\n    error InvalidOwnerAddress();\n\n    event OwnershipTransferStarted(address indexed newOwner);\n    event OwnershipTransferred(address indexed newOwner);\n\n    /**\n     * @notice Returns the current owner of the contract.\n     * @return address The address of the current owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Returns the address of the pending owner of the contract.\n     * @return address The address of the pending owner\n     */\n    function pendingOwner() external view returns (address);\n\n    /**\n     * @notice Transfers ownership of the contract to a new address\n     * @param newOwner The address to transfer ownership to\n     */\n    function transferOwnership(address newOwner) external;\n\n    /**\n     * @notice Proposes to transfer the contract's ownership to a new address.\n     * The new owner needs to accept the ownership explicitly.\n     * @param newOwner The address to transfer ownership to\n     */\n    function proposeOwnership(address newOwner) external;\n\n    /**\n     * @notice Transfers ownership to the pending owner.\n     * @dev Can only be called by the pending owner\n     */\n    function acceptOwnership() external;\n}\n"
      },
      "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IUpgradable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IOwnable } from './IOwnable.sol';\nimport { IImplementation } from './IImplementation.sol';\n\n// General interface for upgradable contracts\ninterface IUpgradable is IOwnable, IImplementation {\n    error InvalidCodeHash();\n    error InvalidImplementation();\n    error SetupFailed();\n\n    event Upgraded(address indexed newImplementation);\n\n    function implementation() external view returns (address);\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata params\n    ) external;\n}\n"
      },
      "@axelar-network/axelar-gmp-sdk-solidity/contracts/types/GasEstimationTypes.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title GasEstimationType\n * @notice This enum represents the gas estimation types for different chains.\n */\nenum GasEstimationType {\n    Default,\n    OptimismEcotone,\n    OptimismBedrock,\n    Arbitrum,\n    Scroll\n}\n\n/**\n * @title GasInfo\n * @notice This struct represents the gas pricing information for a specific chain.\n * @dev Smaller uint types are used for efficient struct packing to save storage costs.\n */\nstruct GasInfo {\n    /// @dev Custom gas pricing rule, such as L1 data fee on L2s\n    uint64 gasEstimationType;\n    /// @dev Scalar value needed for specific gas estimation types, expected to be less than 1e10\n    uint64 l1FeeScalar;\n    /// @dev Axelar base fee for cross-chain message approval on destination, in terms of source native gas token\n    uint128 axelarBaseFee;\n    /// @dev Gas price of destination chain, in terms of the source chain token, i.e dest_gas_price * dest_token_market_price / src_token_market_price\n    uint128 relativeGasPrice;\n    /// @dev Needed for specific gas estimation types. Blob base fee of destination chain, in terms of the source chain token, i.e dest_blob_base_fee * dest_token_market_price / src_token_market_price\n    uint128 relativeBlobBaseFee;\n    /// @dev Axelar express fee for express execution, in terms of source chain token\n    uint128 expressFee;\n}\n"
      },
      "@axelar-network/axelar-gmp-sdk-solidity/contracts/utils/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IOwnable } from '../interfaces/IOwnable.sol';\n\n/**\n * @title Ownable\n * @notice A contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The owner account is set through ownership transfer. This module makes\n * it possible to transfer the ownership of the contract to a new account in one\n * step, as well as to an interim pending owner. In the second flow the ownership does not\n * change until the pending owner accepts the ownership transfer.\n */\nabstract contract Ownable is IOwnable {\n    // keccak256('owner')\n    bytes32 internal constant _OWNER_SLOT = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0;\n    // keccak256('ownership-transfer')\n    bytes32 internal constant _OWNERSHIP_TRANSFER_SLOT =\n        0x9855384122b55936fbfb8ca5120e63c6537a1ac40caf6ae33502b3c5da8c87d1;\n\n    /**\n     * @notice Initializes the contract by transferring ownership to the owner parameter.\n     * @param _owner Address to set as the initial owner of the contract\n     */\n    constructor(address _owner) {\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Modifier that throws an error if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        if (owner() != msg.sender) revert NotOwner();\n\n        _;\n    }\n\n    /**\n     * @notice Returns the current owner of the contract.\n     * @return owner_ The current owner of the contract\n     */\n    function owner() public view returns (address owner_) {\n        assembly {\n            owner_ := sload(_OWNER_SLOT)\n        }\n    }\n\n    /**\n     * @notice Returns the pending owner of the contract.\n     * @return owner_ The pending owner of the contract\n     */\n    function pendingOwner() public view returns (address owner_) {\n        assembly {\n            owner_ := sload(_OWNERSHIP_TRANSFER_SLOT)\n        }\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account `newOwner`.\n     * @dev Can only be called by the current owner.\n     * @param newOwner The address to transfer ownership to\n     */\n    function transferOwnership(address newOwner) external virtual onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Propose to transfer ownership of the contract to a new account `newOwner`.\n     * @dev Can only be called by the current owner. The ownership does not change\n     * until the new owner accepts the ownership transfer.\n     * @param newOwner The address to transfer ownership to\n     */\n    function proposeOwnership(address newOwner) external virtual onlyOwner {\n        if (newOwner == address(0)) revert InvalidOwnerAddress();\n\n        emit OwnershipTransferStarted(newOwner);\n\n        assembly {\n            sstore(_OWNERSHIP_TRANSFER_SLOT, newOwner)\n        }\n    }\n\n    /**\n     * @notice Accepts ownership of the contract.\n     * @dev Can only be called by the pending owner\n     */\n    function acceptOwnership() external virtual {\n        address newOwner = pendingOwner();\n        if (newOwner != msg.sender) revert InvalidOwner();\n\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Internal function to transfer ownership of the contract to a new account `newOwner`.\n     * @dev Called in the constructor to set the initial owner.\n     * @param newOwner The address to transfer ownership to\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        if (newOwner == address(0)) revert InvalidOwnerAddress();\n\n        emit OwnershipTransferred(newOwner);\n\n        assembly {\n            sstore(_OWNER_SLOT, newOwner)\n            sstore(_OWNERSHIP_TRANSFER_SLOT, 0)\n        }\n    }\n}\n"
      },
      "contracts/interfaces/IUniswapAxelarReceiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapAxelarReceiver {\n    event WhitelistedProposalCallerSet(string indexed sourceChain, bytes indexed sourceCaller, bool whitelisted);\n\n    event WhitelistedProposalSenderSet(string indexed sourceChain, string sourceSender, bool whitelisted);\n\n    event ProposalExecuted(bytes32 indexed payloadHash);\n\n    error ProposalExecuteFailed();\n\n    error NotWhitelistedCaller();\n\n    error NotWhitelistedSourceAddress();\n\n    function setWhitelistedProposalSender(\n        string calldata sourceChain,\n        string calldata sourceSender,\n        bool whitelisted\n    ) external;\n\n    function setWhitelistedProposalCaller(\n        string calldata sourceChain,\n        bytes memory sourceCaller,\n        bool whitelisted\n    ) external;\n}"
      },
      "contracts/interfaces/IUniswapAxelarSender.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { UniswapCalls } from '../lib/UniswapCalls.sol';\n\ninterface IUniswapAxelarSender {\n    error InvalidFee();\n\n    error InvalidAddress();\n\n    function sendProposals(UniswapCalls.UniswapCall[] memory calls) external payable;\n\n    function sendProposal(\n        string calldata destinationChain,\n        string calldata destinationContract,\n        UniswapCalls.Call[] calldata calls\n    ) external payable;\n}"
      },
      "contracts/lib/UniswapCalls.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary UniswapCalls {\n    struct UniswapCall {\n        string destinationChain;\n        string destinationContract;\n        uint256 gas;\n        Call[] calls;\n    }\n\n    struct Call {\n        address target;\n        uint256 value;\n        bytes callData;\n    }\n}"
      },
      "contracts/mocks/MockAlexarGateway.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../UniswapAxelarReceiver.sol\";\n\ncontract MockAxelarGateway {\n    mapping(bytes32 => bool) private approvals;\n    mapping(bytes32 => bool) private executed;\n\n    // Event to emit when a contract call is made\n    event ContractCall(\n        address indexed sender,\n        string destinationChain,\n        string destinationContract,\n        bytes32 payloadHash,\n        bytes payload\n    );\n\n    function approveContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external {\n        bytes32 payloadHash = keccak256(payload);\n        approvals[\n            _key(commandId, sourceChain, sourceAddress, payloadHash)\n        ] = true;\n    }\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external view returns (bool) {\n        bytes32 key = _key(commandId, sourceChain, sourceAddress, payloadHash);\n        if (approvals[key]) {\n            return true;\n        }\n        return false;\n    }\n\n    function isCommandExecuted(bytes32 commandId) external view returns (bool) {\n        return executed[commandId];\n    }\n\n    function execute(\n        UniswapAxelarReceiver receiver,\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external {\n        receiver.execute(commandId, sourceChain, sourceAddress, payload);\n    }\n\n    // Add callContract function for UniswapAxelarSender\n    function callContract(\n        string calldata destinationChain,\n        string calldata destinationContract,\n        bytes calldata payload\n    ) external {\n        // Emit event for testing with proper arguments\n        emit ContractCall(\n            msg.sender,\n            destinationChain,\n            destinationContract,\n            keccak256(payload),\n            payload\n        );\n    }\n\n    function _key(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(commandId, sourceChain, sourceAddress, payloadHash)\n            );\n    }\n}\n"
      },
      "contracts/mocks/MockAxelarGasService.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MockAxelarGasService {\n    event NativeGasPaidForContractCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes payload,\n        uint256 gas,\n        address refundAddress\n    );\n\n    function payNativeGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable {\n        emit NativeGasPaidForContractCall(\n            sender,\n            destinationChain,\n            destinationAddress,\n            payload,\n            msg.value,\n            refundAddress\n        );\n    }\n}"
      },
      "contracts/mocks/MockUniswapV3Factory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\ncontract MockUniswapV3Factory {\n    address public owner;\n\n    mapping(uint24 => int24) public feeAmountTickSpacing;\n    mapping(address => mapping(address => mapping(uint24 => address)))\n        public getPool;\n\n    constructor() {\n        owner = msg.sender;\n\n        feeAmountTickSpacing[500] = 10;\n        feeAmountTickSpacing[3000] = 60;\n        feeAmountTickSpacing[10000] = 200;\n    }\n\n    function setOwner(address _owner) external  {\n        require(msg.sender == owner);\n        owner = _owner;\n    }\n\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) public  {\n        require(msg.sender == owner);\n        require(fee < 1000000);\n        require(tickSpacing > 0 && tickSpacing < 16384);\n        require(feeAmountTickSpacing[fee] == 0);\n\n        feeAmountTickSpacing[fee] = tickSpacing;\n    }\n}\n"
      },
      "contracts/UniswapAxelarReceiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol\";\nimport \"@axelar-network/axelar-gmp-sdk-solidity/contracts/utils/Ownable.sol\";\nimport \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IGovernable.sol\";\nimport \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol\";\nimport \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IOwnable.sol\";\nimport \"./interfaces/IUniswapAxelarReceiver.sol\";\nimport \"./lib/UniswapCalls.sol\";\n\ncontract UniswapAxelarReceiver is\n    IUniswapAxelarReceiver,\n    AxelarExecutable,\n    Ownable {\n    mapping(bytes32 => bool) public processedCommands;\n\n    mapping(string => mapping(bytes => bool)) public whitelistedCallers;\n\n    mapping(string => mapping(string => bool)) public whitelistedSenders;\n\n    constructor(\n        address gatewayAddress,\n        address _owner\n    ) AxelarExecutable(gatewayAddress) Ownable(_owner) {\n        require(gatewayAddress != address(0), \"Invalid gateway\");\n    }\n\n    function _execute(\n        bytes32 commandId,\n        string calldata sourceChain_,\n        string calldata sourceAddress_,\n        bytes calldata payload\n    ) internal override {\n        _validateSource(commandId, sourceChain_, sourceAddress_);\n\n        processedCommands[commandId] = true;\n\n        (bytes memory sourceCaller, UniswapCalls.Call[] memory calls) = abi\n            .decode(payload, (bytes, UniswapCalls.Call[]));\n\n        if (!whitelistedCallers[sourceChain_][sourceCaller]) {\n            revert NotWhitelistedCaller();\n        }\n\n        _executeProposal(calls);\n\n        emit ProposalExecuted(\n            keccak256(\n                abi.encode(sourceChain_, sourceAddress_, sourceCaller, payload)\n            )\n        );\n    }\n\n    function _validateSource(\n        bytes32 commandId,\n        string calldata sourceChain_,\n        string calldata sourceAddress_\n    ) private view {\n        if (!whitelistedSenders[sourceChain_][sourceAddress_]) {\n            revert NotWhitelistedSourceAddress();\n        }\n        require(!processedCommands[commandId], \"Command replay\");\n    }\n\n    function setWhitelistedProposalCaller(\n        string calldata sourceChain,\n        bytes memory sourceCaller,\n        bool whitelisted\n    ) external onlyOwner {\n        whitelistedCallers[sourceChain][abi.encodePacked(sourceCaller)] = whitelisted;\n        emit WhitelistedProposalCallerSet(\n            sourceChain,\n            sourceCaller,\n            whitelisted\n        );\n    }\n\n    function setWhitelistedProposalSender(\n        string calldata sourceChain,\n        string calldata sourceSender,\n        bool whitelisted\n    ) external onlyOwner {\n        whitelistedSenders[sourceChain][sourceSender] = whitelisted;\n        emit WhitelistedProposalSenderSet(\n            sourceChain,\n            sourceSender,\n            whitelisted\n        );\n    }\n\n    receive() external payable {}\n\n    function _executeProposal(UniswapCalls.Call[] memory calls) internal {\n        uint256 length = calls.length;\n\n        for (uint256 i = 0; i < length; i++) {\n            UniswapCalls.Call memory call = calls[i];\n            (bool success, bytes memory result) = call.target.call{\n                value: call.value\n            }(call.callData);\n\n            if (!success) {\n                _onTargetExecutionFailed(call, result);\n            }\n        }\n    }\n\n    function _onTargetExecutionFailed(\n        UniswapCalls.Call memory /* call */,\n        bytes memory result\n    ) internal virtual {\n        if (result.length > 0) {\n            assembly {\n                revert(add(32, result), mload(result))\n            }\n        } else {\n            revert ProposalExecuteFailed();\n        }\n    }\n}\n"
      },
      "contracts/UniswapAxelarSender.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol';\nimport { IAxelarGasService } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol';\nimport { IUniswapAxelarSender } from './interfaces/IUniswapAxelarSender.sol';\nimport { UniswapCalls } from './lib/UniswapCalls.sol';\n\ncontract UniswapAxelarSender is IUniswapAxelarSender {\n    IAxelarGateway public immutable gateway;\n    IAxelarGasService public immutable gasService;\n\n    constructor(address _gateway, address _gasService) {\n        if (_gateway == address(0) || _gasService == address(0)) revert InvalidAddress();\n\n        gateway = IAxelarGateway(_gateway);\n        gasService = IAxelarGasService(_gasService);\n    }\n\n    function sendProposals(UniswapCalls.UniswapCall[] calldata calls) external payable override {\n        // revert if the sum of given fees are not equal to the msg.value\n        revertIfInvalidFee(calls);\n\n        uint256 length = calls.length;\n\n        for (uint256 i = 0; i < length; ) {\n            _sendProposal(calls[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function sendProposal(\n        string memory destinationChain,\n        string memory destinationContract,\n        UniswapCalls.Call[] calldata calls\n    ) external payable override {\n        _sendProposal(UniswapCalls.UniswapCall(destinationChain, destinationContract, msg.value, calls));\n    }\n\n    function _sendProposal(UniswapCalls.UniswapCall memory UniswapCall) internal {\n        bytes memory payload = abi.encode(abi.encodePacked(msg.sender), UniswapCall.calls);\n\n        if (UniswapCall.gas > 0) {\n            gasService.payNativeGasForContractCall{ value: UniswapCall.gas }(\n                address(this),\n                UniswapCall.destinationChain,\n                UniswapCall.destinationContract,\n                payload,\n                msg.sender\n            );\n        }\n\n        gateway.callContract(UniswapCall.destinationChain, UniswapCall.destinationContract, payload);\n    }\n\n    function revertIfInvalidFee(UniswapCalls.UniswapCall[] calldata calls) private {\n        uint256 totalGas = 0;\n        uint256 length = calls.length;\n\n        for (uint256 i = 0; i < length; ) {\n            totalGas += calls[i].gas;\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (totalGas != msg.value) {\n            revert InvalidFee();\n        }\n    }\n}"
      }
    },
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 1000000
      },
      "evmVersion": "london",
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ],
          "": [
            "ast"
          ]
        }
      }
    }
  }